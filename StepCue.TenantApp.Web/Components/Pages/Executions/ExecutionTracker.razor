@page "/executions/{Id:int}"
@page "/executions/create/{PlanId:int}"
@using StepCue.TenantApp.Core.Services
@using StepCue.TenantApp.Data.Models.Execution
@using StepCue.TenantApp.Data.Models.Planning
@using StepCue.TenantApp.Web.Services
@inject ExecutionService ExecutionService
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@inject IDialogService DialogService
@rendermode InteractiveServer

<style>
    .highlighted-step {
        background-color: var(--mud-palette-primary-lighten) !important;
        border: 2px solid var(--mud-palette-primary) !important;
        border-radius: 8px;
    }
    
    .timeline-container {
        position: relative;
        padding-left: 2rem;
    }
    
    .timeline-item {
        position: relative;
        margin-bottom: 2rem;
        display: flex;
        align-items: flex-start;
    }
    
    .timeline-item.disabled .timeline-content {
        opacity: 0.6;
        cursor: not-allowed !important;
    }
    
    .timeline-item.highlighted .timeline-content {
        border: 2px solid var(--mud-palette-primary) !important;
        background-color: var(--mud-palette-primary-lighten) !important;
    }
    
    .timeline-item.current .timeline-content {
        border: 3px solid var(--mud-palette-warning) !important;
        background-color: var(--mud-palette-warning-lighten) !important;
        box-shadow: 0 4px 20px rgba(255, 193, 7, 0.2) !important;
    }
    
    .timeline-indicator {
        position: absolute;
        left: -2rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        z-index: 2;
    }
    
    .timeline-line {
        width: 2px;
        height: 3rem;
        background-color: var(--mud-palette-lines-default);
        margin-top: 0.5rem;
    }
    
    .timeline-line.completed-line {
        background-color: var(--mud-palette-success);
    }
    
    .timeline-content {
        flex: 1;
        margin-left: 1rem;
        transition: all 0.2s ease;
    }
    
    .timeline-content:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 20px rgba(0,0,0,0.1) !important;
    }
    
    .timeline-item.disabled .timeline-content:hover {
        transform: none;
    }
    
    .selected-step {
        border: 2px solid var(--mud-palette-primary) !important;
    }
</style>

<PageTitle>Execution Tracker</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="mt-4">
    @if (_execution == null)
    {
        <MudProgressCircular Indeterminate="true" />
    }
    else
    {
        <MudText Typo="Typo.h4" Class="mb-2">@_execution.Name</MudText>
        <MudText Typo="Typo.subtitle1" Class="mb-4">Based on plan: @_execution.Plan?.Name</MudText>
        
        <!-- Horizontal Progress Timeline -->
        <MudCard Elevation="2" Class="mb-4">
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">Overall Progress</MudText>
                <MudProgressLinear Color="Color.Primary" Value="@GetExecutionProgress()" Class="mb-2" />
                <MudText Typo="Typo.caption">@(_execution.Steps.Count(s => ExecutionService.IsStepComplete(s))) of @_execution.Steps.Count steps completed</MudText>
                
                <!-- Horizontal step indicators -->
                <div class="d-flex justify-center mt-3" style="gap: 8px;">
                    @for (int i = 0; i < _execution.Steps.Count; i++)
                    {
                        var step = _execution.Steps[i];
                        var stepNumber = i + 1;
                        var isCompleted = ExecutionService.IsStepComplete(step);
                        var isStarted = step.StartedOn.HasValue;
                        var isCurrent = _selectedStep?.Id == step.Id;
                        
                        <MudTooltip Text="@step.Name">
                            <MudButton Variant="@(isCurrent ? Variant.Filled : Variant.Outlined)"
                                     Color="@(isCompleted ? Color.Success : isStarted ? Color.Info : Color.Default)"
                                     Size="Size.Small"
                                     Class="rounded-circle"
                                     Style="min-width: 40px; height: 40px;"
                                     OnClick="@(() => SelectStep(step))">
                                @if (isCompleted)
                                {
                                    <MudIcon Icon="@Icons.Material.Filled.Check" />
                                }
                                else
                                {
                                    @stepNumber
                                }
                            </MudButton>
                        </MudTooltip>
                    }
                </div>
            </MudCardContent>
        </MudCard>

        <!-- Vertical Timeline -->
        <MudGrid>
            <MudItem xs="12" md="8">
                <div class="timeline-container">
                    @for (int i = 0; i < _execution.Steps.Count; i++)
                    {
                        var step = _execution.Steps[i];
                        var isLast = i == _execution.Steps.Count - 1;
                        var isCompleted = ExecutionService.IsStepComplete(step);
                        var isStarted = step.StartedOn.HasValue;
                        var canStart = CanStartStep(step);
                        var isHighlighted = IsStepHighlighted(step);
                        var isCurrent = IsCurrentStep(step);
                        var shouldShow = _selectedMemberToHighlight == null || isHighlighted;
                        
                        @if (shouldShow)
                        {
                        <div class="timeline-item @(isCompleted ? "completed" : isStarted ? "started" : !canStart ? "disabled" : "") @(isHighlighted ? "highlighted" : "") @(isCurrent ? "current" : "")">
                            <!-- Timeline indicator -->
                            <div class="timeline-indicator">
                                <MudIcon Icon="@GetStepIcon(step)" 
                                       Color="@GetStepColor(step)" 
                                       Size="Size.Large" />
                                @if (!isLast)
                                {
                                    <div class="timeline-line @(isCompleted ? "completed-line" : "")"></div>
                                }
                            </div>
                            
                            <!-- Timeline content -->
                            <MudCard Elevation="2" 
                                   Class="@($"timeline-content ma-2 {(step.Id == _selectedStep?.Id ? "selected-step" : "")}")"
                                   @onclick="@(() => OpenStepDialog(step))"
                                   Style="cursor: pointer;">
                                <MudCardContent>
                                    <div class="d-flex justify-space-between align-center mb-2">
                                        <div class="d-flex align-center" style="gap: 8px;">
                                            <MudText Typo="Typo.h6">@step.Name</MudText>
                                            @if (step.StepType == StepCue.TenantApp.Data.Models.Planning.StepType.GoNoGo)
                                            {
                                                @if (step.FallbackOriginStepId.HasValue)
                                                {
                                                    <MudChip T="string" Color="Color.Error" Size="Size.Small" Variant="Variant.Outlined">Fallback Approval</MudChip>
                                                }
                                                else
                                                {
                                                    <MudChip T="string" Color="Color.Warning" Size="Size.Small" Variant="Variant.Outlined">Go/NoGo</MudChip>
                                                }
                                            }
                                        </div>
                                        <div>
                                            @if (step.IsCancelled)
                                            {
                                                <MudChip T="string" Color="Color.Dark" Size="Size.Small">Cancelled</MudChip>
                                            }
                                            else if (isStarted && !isCompleted)
                                            {
                                                <MudChip T="string" Color="Color.Info" Size="Size.Small">@GetTimeSinceStarted(step)</MudChip>
                                            }
                                            else if (isCompleted)
                                            {
                                                <MudChip T="string" Color="Color.Success" Size="Size.Small">Completed</MudChip>
                                            }
                                            else if (!canStart)
                                            {
                                                <MudChip T="string" Color="Color.Default" Size="Size.Small">Waiting</MudChip>
                                            }
                                        </div>
                                    </div>
                                    
                                    @if (!string.IsNullOrEmpty(step.Summary))
                                    {
                                        <MudText Typo="Typo.body2" Class="mb-2">@step.Summary</MudText>
                                    }
                                    
                                    @if (step.AssignedMembers != null && step.AssignedMembers.Any())
                                    {
                                        <div class="d-flex flex-wrap gap-1 mb-2">
                                            <MudText Typo="Typo.caption" Class="align-self-center mr-2">Assigned to:</MudText>
                                            @foreach (var member in step.AssignedMembers)
                                            {
                                                <MudChip T="string" Color="Color.Secondary" Size="Size.Small">@member.Name</MudChip>
                                            }
                                        </div>
                                    }
                                    
                                    @if (step.Screenshot != null && step.Screenshot.Length > 0)
                                    {
                                        <MudText Typo="Typo.caption" Class="d-block">ðŸ“· Screenshot available</MudText>
                                    }
                                    
                                    <div class="d-flex justify-space-between align-center mt-3">
                                        <div>
                                            @if (isCompleted)
                                            {
                                                <MudText Typo="Typo.caption">Completed on @step.CompleteOn.Value.ToShortDateString()</MudText>
                                            }
                                            else if (isStarted)
                                            {
                                                <MudText Typo="Typo.caption">Started on @step.StartedOn.Value.ToShortDateString()</MudText>
                                            }
                                            else
                                            {
                                                <MudText Typo="Typo.caption">Not started</MudText>
                                            }
                                        </div>
                                        
                                        <div class="d-flex gap-2 align-center">
                                            <!-- Don't show action buttons for cancelled steps -->
                                            @if (!step.IsCancelled && !isCompleted && canStart)
                                            {
                                                @if (step.StepType == StepCue.TenantApp.Data.Models.Planning.StepType.GoNoGo)
                                                {
                                                    <MudButton Variant="Variant.Filled" 
                                                             Color="@(step.FallbackOriginStepId.HasValue ? Color.Error : Color.Warning)" 
                                                             Size="Size.Small"
                                                             OnClick="@(async () => await OpenStepApprovalDialog(step))"
                                                             onclick:stopPropagation="true">
                                                        @(step.FallbackOriginStepId.HasValue ? "Approve Fallback" : "Approve")
                                                    </MudButton>
                                                }
                                                else if (!isStarted)
                                                {
                                                    <MudButton Variant="Variant.Filled" 
                                                             Color="Color.Primary" 
                                                             Size="Size.Small"
                                                             OnClick="@(async () => await StartStepInternal(step))"
                                                             onclick:stopPropagation="true">
                                                        Start
                                                    </MudButton>
                                                }
                                                else
                                                {
                                                    <MudButton Variant="Variant.Filled" 
                                                             Color="Color.Success" 
                                                             Size="Size.Small"
                                                             OnClick="@(() => OpenStepCompletionDialog(step))"
                                                             onclick:stopPropagation="true">
                                                        Complete
                                                    </MudButton>
                                                }
                                            }
                                            
                                            <!-- Fallback button - show for started execution steps that come after steps with fallback definitions -->
                                            @if (!step.IsCancelled && isStarted && !isCompleted && 
                                                 step.StepType == StepCue.TenantApp.Data.Models.Planning.StepType.Execution && 
                                                 HasAnyPreviousStepWithFallback(step))
                                            {
                                                <MudButton Variant="Variant.Filled" 
                                                         Color="Color.Error" 
                                                         Size="Size.Small"
                                                         OnClick="@(() => OpenFallbackDialog(step))"
                                                         onclick:stopPropagation="true">
                                                    Fallback
                                                </MudButton>
                                            }
                                        </div>
                                        
                                        @if (step.IsCancelled)
                                        {
                                            <MudText Typo="Typo.caption" Style="color: var(--mud-palette-text-secondary);">Cancelled due to fallback</MudText>
                                        }
                                        else
                                        {
                                            <MudText Typo="Typo.caption" Style="color: var(--mud-palette-text-secondary);">Click for details</MudText>
                                        }
                                    </div>
                                </MudCardContent>
                            </MudCard>
                        </div>
                        }
                    }
                    
                    @if (_selectedMemberToHighlight != null && !_execution.Steps.Any(s => IsStepHighlighted(s)))
                    {
                        <div class="text-center pa-4">
                            <MudText Typo="Typo.caption" Style="font-style: italic;">No steps assigned to this member</MudText>
                        </div>
                    }
                </div>
            </MudItem>
            
            <MudItem xs="12" md="4">
                <MudPaper Class="pa-4" Elevation="2">
                    <MudText Typo="Typo.h6" Class="mb-2">Team Members</MudText>
                    @foreach (var member in _execution.Members)
                    {
                        <MudChip T="String" Color="Color.Primary" Class="ma-1">@member.Name</MudChip>
                    }
                </MudPaper>
                
                @if (_execution.Members.Any())
                {
                    <MudPaper Class="pa-4 mt-3" Elevation="2">
                        <MudText Typo="Typo.h6" Class="mb-2">Filter by Member</MudText>
                        <MudSelect T="ExecutionMember" @bind-Value="_selectedMemberToHighlight" 
                                   Label="Highlight steps for member" 
                                   Variant="Variant.Outlined" 
                                   Clearable="true"
                                   ToStringFunc="@(m => string.IsNullOrEmpty(m?.Name) ? "Unnamed Member" : m.Name)">
                            @foreach (var member in _execution.Members)
                            {
                                var memberName = string.IsNullOrEmpty(member.Name) ? "Unnamed Member" : member.Name;
                                <MudSelectItem T="ExecutionMember" Value="@member">@memberName</MudSelectItem>
                            }
                        </MudSelect>
                    </MudPaper>
                }
            </MudItem>
        </MudGrid>
    }
</MudContainer>









@code {
    [Parameter]
    public int? Id { get; set; }
    
    [Parameter]
    public int? PlanId { get; set; }
    
    private Execution _execution;
    private ExecutionStep _selectedStep;
    private ExecutionMember? _selectedMemberToHighlight;
    private Dictionary<int, bool> _stepFallbackAvailability = new();
    
    [Inject] 
    private FileService? _fileService { get; set; }
    
    protected override async Task OnInitializedAsync()
    {
        if (PlanId.HasValue)
        {
            // Creating a new execution from plan
            _execution = await ExecutionService.CreateExecutionFromPlanAsync(PlanId.Value);
            if (_execution != null)
            {
                Id = _execution.Id;
                NavigationManager.NavigateTo($"/executions/{Id}", replace: true);
                // Load fallback availability for the new execution
                await LoadFallbackAvailabilityAsync();
            }
            else
            {
                NavigationManager.NavigateTo("/plans");
                Snackbar.Add("Failed to create execution. Plan not found.", Severity.Error);
            }
        }
        else if (Id.HasValue)
        {
            // Loading existing execution
            _execution = await ExecutionService.GetExecutionAsync(Id.Value);
            if (_execution == null)
            {
                NavigationManager.NavigateTo("/executions");
                Snackbar.Add("Execution not found", Severity.Error);
            }
            else
            {
                // Load fallback availability for the existing execution
                await LoadFallbackAvailabilityAsync();
            }
            
            if (_execution?.Steps.Count > 0)
            {
                // Select first incomplete step, or the last step if all are complete
                _selectedStep = _execution.Steps.FirstOrDefault(s => !ExecutionService.IsStepComplete(s)) ?? 
                               _execution.Steps.Last();
            }
        }
    }
    
    private void SelectStep(ExecutionStep step)
    {
        _selectedStep = step;
    }
    
    private async Task OpenStepDialog(ExecutionStep step)
    {
        var model = new StepDetailsDialogModel
        {
            Step = step,
            CanStart = CanStartStep(step),
            IsCompleted = ExecutionService.IsStepComplete(step)
        };
        
        var parameters = new DialogParameters<StepDetailsDialog>
        {
            { x => x.Model, model }
        };
        
        var dialog = await DialogService.ShowAsync<StepDetailsDialog>(step.Name ?? "Step Details", parameters);
        var result = await dialog.Result;
        
        if (!result.Canceled && result.Data is StepDetailsDialogModel resultModel)
        {
            // Refresh the execution data to get latest updates
            _execution = await ExecutionService.GetExecutionAsync(_execution.Id);
            StateHasChanged();
        }
    }
    
    private string GetTimeSinceStarted(ExecutionStep step)
    {
        if (!step.StartedOn.HasValue) return "";
        
        var timeSpan = DateTime.Now - step.StartedOn.Value;
        
        if (timeSpan.TotalDays >= 1)
            return $"{(int)timeSpan.TotalDays} day(s) ago";
        if (timeSpan.TotalHours >= 1)
            return $"{(int)timeSpan.TotalHours} hour(s) ago";
        if (timeSpan.TotalMinutes >= 1)
            return $"{(int)timeSpan.TotalMinutes} minute(s) ago";
        
        return "Just started";
    }
    
    private double GetExecutionProgress()
    {
        if (_execution?.Steps == null || !_execution.Steps.Any()) return 0;
        
        var completedSteps = _execution.Steps.Count(s => ExecutionService.IsStepComplete(s));
        return (double)completedSteps / _execution.Steps.Count * 100;
    }
    
    private async Task StartStep()
    {
        await StartStepInternal(_selectedStep);
    }
    
    private async Task StartStepInternal(ExecutionStep step)
    {
        if (!CanStartStep(step))
        {
            Snackbar.Add("Cannot start this step. Previous steps must be completed first.", Severity.Warning);
            return;
        }
        
        step.StartedOn = DateTime.Now;
        await ExecutionService.UpdateExecutionStepAsync(step);
        Snackbar.Add("Step started", Severity.Info);
    }
    
    private async Task CompleteStep()
    {
        await CompleteStepInternal(_selectedStep);
    }
    
    private async Task CompleteStepInternal(ExecutionStep step)
    {
        step.CompleteOn = DateTime.Now;
        await ExecutionService.UpdateExecutionStepAsync(step);
        Snackbar.Add("Step completed", Severity.Success);
        
        // Select next incomplete step if available and we're working with the main selected step
        if (step == _selectedStep)
        {
            var nextStep = _execution.Steps
                .Where(s => !ExecutionService.IsStepComplete(s) && s.Id != step.Id)
                .OrderBy(s => s.Order)
                .FirstOrDefault();
                
            if (nextStep != null)
            {
                _selectedStep = nextStep;
            }
        }
    }
    
    private string GetStepIcon(ExecutionStep step)
    {
        if (ExecutionService.IsStepComplete(step))
            return Icons.Material.Filled.CheckCircle;
        if (step.StartedOn.HasValue)
            return Icons.Material.Filled.PlayCircle;
        return Icons.Material.Filled.Circle;
    }
    
    private Color GetStepColor(ExecutionStep step)
    {
        if (ExecutionService.IsStepComplete(step))
            return Color.Success;
        if (step.StartedOn.HasValue)
            return Color.Info;
        return Color.Default;
    }
    
    private bool CanStartStep(ExecutionStep step)
    {
        // Check if all steps with lower order numbers are completed
        var stepsBeforeThisOne = _execution.Steps
            .Where(s => s.Order < step.Order)
            .ToList();
            
        // If there are no steps before this one, it can always be started
        if (!stepsBeforeThisOne.Any()) return true;
        
        // Check if all previous steps are completed
        return stepsBeforeThisOne.All(s => ExecutionService.IsStepComplete(s));
    }
    
    private bool IsStepHighlighted(ExecutionStep step)
    {
        if (_selectedMemberToHighlight == null)
            return false;
            
        return step.AssignedMembers.Any(m => m.Id == _selectedMemberToHighlight.Id);
    }
    
    private bool IsCurrentStep(ExecutionStep step)
    {
        // Current step is the first incomplete step that can be started
        if (ExecutionService.IsStepComplete(step)) return false; // Already completed
        
        var firstIncompleteStep = _execution.Steps
            .Where(s => !ExecutionService.IsStepComplete(s) && CanStartStep(s))
            .OrderBy(s => s.Order)
            .FirstOrDefault();
            
        return firstIncompleteStep?.Id == step.Id;
    }
    
    private async Task OpenStepCompletionDialog(ExecutionStep step)
    {
        var model = new StepCompletionDialogModel
        {
            Step = step,
            ResultSummary = step.ResultSummary ?? string.Empty,
            WentWell = step.WhatWentWell ?? string.Empty,
            CouldBeBetter = step.WhatCouldBeBetter ?? string.Empty,
            Screenshot = step.ResultScreenshot
        };
        
        var parameters = new DialogParameters<StepCompletionDialog>
        {
            { x => x.Model, model }
        };
        
        var dialog = await DialogService.ShowAsync<StepCompletionDialog>("Complete Step", parameters);
        var result = await dialog.Result;
        
        if (!result.Canceled && result.Data is StepCompletionDialogModel resultModel)
        {
            // Refresh the execution data to get latest updates
            _execution = await ExecutionService.GetExecutionAsync(_execution.Id);
            
            // Select next incomplete step if available and we're working with the main selected step
            if (step == _selectedStep)
            {
                var nextStep = _execution.Steps
                    .Where(s => !ExecutionService.IsStepComplete(s) && s.Id != step.Id)
                    .OrderBy(s => s.Order)
                    .FirstOrDefault();
                    
                if (nextStep != null)
                {
                    _selectedStep = nextStep;
                }
            }
            
            StateHasChanged();
        }
    }
    

    
    private async Task OpenStepApprovalDialog(ExecutionStep step)
    {
        // Auto-start the step if it hasn't been started yet (for go/nogo steps)
        if (!step.StartedOn.HasValue)
        {
            step.StartedOn = DateTime.Now;
            await ExecutionService.UpdateExecutionStepAsync(step);
        }
        
        var model = new StepApprovalDialogModel
        {
            Step = step,
            SelectedApprover = null,
            Comments = string.Empty
        };
        
        var parameters = new DialogParameters<StepApprovalDialog>
        {
            { x => x.Model, model }
        };
        
        var dialog = await DialogService.ShowAsync<StepApprovalDialog>("Approve Step", parameters);
        var result = await dialog.Result;
        
        if (!result.Canceled && result.Data is StepApprovalDialogModel resultModel)
        {
            // Refresh the execution data to get latest updates
            _execution = await ExecutionService.GetExecutionAsync(_execution.Id);
            StateHasChanged();
        }
    }
    

    
    // Helper method to check if a step has fallback definitions
    private bool HasFallbackSteps(ExecutionStep step)
    {
        return _stepFallbackAvailability.GetValueOrDefault(step.Order, false);
    }
    
    // Helper method to check if any previous step has fallback definitions
    private bool HasAnyPreviousStepWithFallback(ExecutionStep step)
    {
        // Check if any step with a lower order number has fallback definitions
        return _stepFallbackAvailability.Where(kvp => kvp.Key < step.Order && kvp.Value).Any();
    }
    
    // Helper method to load fallback availability for all steps
    private async Task LoadFallbackAvailabilityAsync()
    {
        _stepFallbackAvailability.Clear();
        
        if (_execution?.Steps == null)
            return;
        
        foreach (var step in _execution.Steps)
        {
            var planStepOrder = step.PlanStepOrder ?? step.Order;
            var hasFeatures = await ExecutionService.HasFallbackStepsAsync(_execution.Id, planStepOrder);
            _stepFallbackAvailability[step.Order] = hasFeatures;
        }
    }
    
    // Helper method to load fallback definitions for a step
    private async Task<List<Fallback>> LoadFallbackStepsAsync(ExecutionStep step)
    {
        if (_execution == null)
            return new List<Fallback>();
        
        var planStepOrder = step.PlanStepOrder ?? step.Order;
        return await ExecutionService.GetFallbackStepsAsync(_execution.Id, planStepOrder);
    }
    
    // Helper method to load all available fallback options from previous steps
    private async Task<Dictionary<int, List<Fallback>>> LoadAllAvailableFallbacksAsync(ExecutionStep currentStep)
    {
        var result = new Dictionary<int, List<Fallback>>();
        
        if (_execution == null)
            return result;
        
        // Find all previous steps that have fallback definitions
        var previousStepsWithFallbacks = _stepFallbackAvailability
            .Where(kvp => kvp.Key < currentStep.Order && kvp.Value)
            .Select(kvp => kvp.Key)
            .OrderByDescending(order => order); // Most recent first
        
        foreach (var stepOrder in previousStepsWithFallbacks)
        {
            var fallbacks = await ExecutionService.GetFallbackStepsAsync(_execution.Id, stepOrder);
            if (fallbacks.Any())
            {
                result[stepOrder] = fallbacks;
            }
        }
        
        return result;
    }
    
    // Fallback methods
    private async Task OpenFallbackDialog(ExecutionStep step)
    {
        var availableFallbackOptions = await LoadAllAvailableFallbacksAsync(step);
        
        var model = new FallbackDialogModel
        {
            Step = step,
            Reason = string.Empty,
            AvailableFallbackOptions = availableFallbackOptions,
            SelectedFallbackStepOrder = null,
            CurrentFallbackSteps = new List<Fallback>()
        };
        
        // If there's only one option, select it automatically
        if (availableFallbackOptions.Count == 1)
        {
            model.SelectedFallbackStepOrder = availableFallbackOptions.Keys.First();
            model.CurrentFallbackSteps = availableFallbackOptions[model.SelectedFallbackStepOrder.Value];
        }
        
        var parameters = new DialogParameters<FallbackDialog>
        {
            { x => x.Model, model },
            { x => x.ExecutionSteps, _execution?.Steps }
        };
        
        var dialog = await DialogService.ShowAsync<FallbackDialog>("Request Fallback", parameters);
        var result = await dialog.Result;
        
        if (!result.Canceled && result.Data is FallbackDialogModel resultModel)
        {
            // Refresh the execution data to get latest updates
            _execution = await ExecutionService.GetExecutionAsync(_execution.Id);
            await LoadFallbackAvailabilityAsync();
            
            // Select the new approval step if one was created
            if (resultModel.Step != null)
            {
                var newApprovalStep = _execution.Steps
                    .Where(s => s.FallbackOriginStepId == resultModel.Step.Id)
                    .OrderByDescending(s => s.Id)
                    .FirstOrDefault();
                    
                if (newApprovalStep != null)
                {
                    _selectedStep = newApprovalStep;
                }
            }
            
            StateHasChanged();
        }
    }
}